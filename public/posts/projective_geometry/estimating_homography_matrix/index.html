<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>üë®üèª‚Äçüíª Projective Geometry: Estimating the homography matrix | I√±aki‚Äôs Log</title>
<meta name="keywords" content="computer vision, projective geometry, homography matrix, pinhole camera">
<meta name="description" content="Table of Contents 1. Introduction 2. Via geometric features 2.1. From points/lines 2.1.1. Problem formulation 2.1.2. Noise amplification: the horizon line 2.1.3. Solution: least squares estimator 2.2. From conics 2.3. From multiple features 3. Via a pair images 4. Via ML model 5. Summary 6. References 1. Introduction So far, we have figured out how to:
Mathematically characterize the transform between the 3D world and a 2D image of it Map different types of objects between the two domains However, one might wonder: how do we actually compute the homography matrix that fully describes that transform in the first place?">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/projective_geometry/estimating_homography_matrix/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/projective_geometry/estimating_homography_matrix/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>


<script>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "$", right: "$", display: false}
        ]
    });
});
</script>

</head>

<body class="" id="top">

<head>
  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-X47ZD00R5L"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-X47ZD00R5L', { 'anonymize_ip': false });
}
</script>

</head>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="I√±aki‚Äôs Log (Alt + H)">I√±aki‚Äôs Log</a>
            <div class="logo-switches">
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="üìö Posts">
                    <span>üìö Posts</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="üè∑Ô∏è Tags">
                    <span>üè∑Ô∏è Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="üîç Search (Alt &#43; /)" accesskey=/>
                    <span>üîç Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/" title="üëã About">
                    <span>üëã About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      üë®üèª‚Äçüíª Projective Geometry: Estimating the homography matrix
    </h1>
    <div class="post-meta"><span title='2023-10-15 11:16:19 +0100 +0100'>October 15, 2023</span>

</div>
  </header> 
  <div class="post-content"><span style="background-color: lightgrey; border: 1px solid black; padding: 2px 10px; display: inline-flex; align-items: center;">
  <details>
    <summary><strong>Table of Contents</strong></summary>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#1-introduction">1. Introduction</a></li>
    <li><a href="#2-via-geometric-features">2. Via geometric features</a>
      <ul>
        <li><a href="#21-from-pointslines">2.1. From points/lines</a>
          <ul>
            <li><a href="#211-problem-formulation">2.1.1. Problem formulation</a></li>
            <li><a href="#212-noise-amplification-the-horizon-line">2.1.2. Noise amplification: the horizon line</a></li>
            <li><a href="#213-solution-least-squares-estimator"><strong>2.1.3. Solution: least squares estimator</strong></a></li>
          </ul>
        </li>
        <li><a href="#22-from-conics">2.2. From conics</a></li>
        <li><a href="#23-from-multiple-features">2.3. From multiple features</a></li>
      </ul>
    </li>
    <li><a href="#3-via-a-pair-images">3. Via a pair images</a></li>
    <li><a href="#4-via-ml-model">4. Via ML model</a></li>
    <li><a href="#5-summary">5. Summary</a></li>
    <li><a href="#6-references">6. References</a></li>
  </ul>
</nav>
  </details>
</span>
<h1 id="1-introduction">1. Introduction<a hidden class="anchor" aria-hidden="true" href="#1-introduction">#</a></h1>
<p>So far, we have figured out how to:</p>
<ol>
<li>Mathematically characterize the transform between the 3D world and a 2D image of it</li>
<li>Map different types of objects between the two domains</li>
</ol>
<p>However, one might wonder: how do we actually compute the homography matrix that fully describes that transform in the first place? In this post, we will explain different approaches to do precisely that.</p>
<div style="background-color: lightyellow; border: 1px solid black; padding: 2px 10px; display: flex; align-items: start;">
  <span style="margin-right: 10px;">‚ö†Ô∏è</span>
  <span>
    There are multiple ways to characterize the perspective transform. In this post we will focus on estimating the homography matrix, as oposed to the more interpretable KRT parametrisation (focal length, rotation angles and 3D location). <br><br>
    The reason for that choice is the implicit assumption that we are only given a 2D image to characterize the transform. Under that constraint, the KRT parametrisation is not resolvable, as illustrated in the image below. If we have a zenithal view of the pitch, we could end up capturing the exact same image by varying accordingly the distance to the ground and the focal length. <br><br>
    To resolve the ambiguity, we would need correspondences between points in the captured 2D image and non-coplanar points in the 3D world. <br><br>
    <figure class="figure" style="text-align: center;">
      <img src="/estimating_homography_matrix/CameraParametersAmbiguity.png" alt="Camera Parameters Ambiguity" width="80%" style="display: block; margin: auto;">
      <figcaption class="caption" style="font-weight: normal; max-width: 80%; margin: auto;">Depiction of a soccer field photographed by two different cameras from a zenithal view. By adjusting the focal length, it is possible to capture the exact same image of the field from both angles. This illustrates the ambiguity in trying to retrieve the camera parameters from a 2D image.</figcaption>
    </figure>
  </span>
</div> <br>
<span style="background-color: lightblue; border: 1px solid black; padding: 2px 10px; display: inline-flex; align-items: center;">
    <img src="/github.svg" alt="GitHub Icon" style="width: 24px; height: 24px; margin-right: 10px;">
    <a href="https://github.com/InakiRaba91/ProjectiveGeometry" style="text-decoration: none; color: blue; line-height: 1;"><strong>Auxiliary repository</strong></a>
</span>
<h1 id="2-via-geometric-features">2. Via geometric features<a hidden class="anchor" aria-hidden="true" href="#2-via-geometric-features">#</a></h1>
<p>We have explained in an earlier post how different types of geometric features $g$ are mapped between the two domains via the homography matrix: $g&rsquo;=f_1(H, g)$. If we are able to identify corresponding features in both domains, we could then try to find a way to revert this process and compute $H=f_2(g, g&rsquo;)$.</p>
<h2 id="21-from-pointslines">2.1. From points/lines<a hidden class="anchor" aria-hidden="true" href="#21-from-pointslines">#</a></h2>
<p>Let us start by the simplest scenario where all equations are linear. For the sake of simplicity, we will focus on the retrieval of the homography from a set of point correspondences. However, notice there is a duality between points $\Longleftrightarrow$ lines.</p>
<p>$$
\begin{equation}
\vec{p&rsquo;}=H\cdot\vec{p}
\end{equation}
$$</p>
<p>$$
\begin{equation}
\vec{l}=H^T\cdot\vec{l&rsquo;}
\end{equation}
$$</p>
<p>As a result, the process of retrieving the homography from a set of line correspondences would be completely analogous.</p>
<figure class="figure" style="text-align: center;">
  <img src="/estimating_homography_matrix/NonColinearity.png" alt="Non Colinearity" width="90%" style="display: block; margin: auto;">
  <figcaption class="caption" style="font-weight: normal; max-width: 80%; margin: auto;">Example of non-collinear pairs of points and non-concurrent pairs of lines that would allow to retrieve the homography matrix.</figcaption>
</figure>
<h3 id="211-problem-formulation">2.1.1. Problem formulation<a hidden class="anchor" aria-hidden="true" href="#211-problem-formulation">#</a></h3>
<p>We can expand the equation for projecting a point in homogenous coordinates between two 2D planes:</p>
<p>$$
\begin{equation}
s\cdot
\begin{bmatrix}
x&rsquo; \\
y&rsquo; \\
1 \\
\end{bmatrix}=
\begin{bmatrix}
h_{11} &amp; h_{12} &amp; h_{13}\\
h_{21} &amp; h_{22} &amp; h_{23}\\
h_{31} &amp; h_{32} &amp; h_{33}\\
\end{bmatrix} \cdot
\begin{bmatrix}
x \\
y \\
1 \\
\end{bmatrix}
\end{equation}
$$</p>
<p>For each homogenous coordinate, we get:</p>
<p>$$
\begin{equation}
s\cdot x&rsquo;=h_{11}\cdot x + h_{12}\cdot y + h_{33}
\end{equation}
$$</p>
<p>$$
\begin{equation}
s\cdot y&rsquo;=h_{21}\cdot x + h_{22}\cdot y + h_{23}
\end{equation}
$$</p>
<p>$$
\begin{equation}
s=h_{31}\cdot x + h_{32}\cdot y + h_{33}
\end{equation}
$$</p>
<p>By replacing $s$ we arrive at:</p>
<p>$$
\begin{equation}
h_{31} \cdot x\cdot x&rsquo; + h_{32}\cdot y \cdot x&rsquo; + h_{33}\cdot x&rsquo;=h_{11}\cdot x + h_{12}\cdot y + h_{33}
\end{equation}
$$</p>
<p>$$
\begin{equation}
h_{31} \cdot x\cdot y&rsquo; + h_{32}\cdot y \cdot y&rsquo; + h_{33}\cdot y&rsquo;=h_{21}\cdot x + h_{22}\cdot y + h_{23}
\end{equation}
$$</p>
<p>We can vectorise the homography matrix elements into</p>
<p>$$
\begin{equation}
\vec{h}=\left[ h_{11}, h_{12}, h_{13}, h_{21}, h_{22}, h_{23}, h_{31}, h_{32}, h_{33}\right]^T
\end{equation}
$$</p>
<p>which gives us the following homogenous system:</p>
<p>$$
\begin{equation}
\begin{bmatrix}
x &amp; y &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; -xx&rsquo; &amp; -yx&rsquo;&amp; -x&rsquo;\\
0 &amp; 0 &amp; 0 &amp; x &amp; y &amp; 1 &amp; -xy&rsquo; &amp; -yy&rsquo;&amp; -y&rsquo;\
\end{bmatrix} \cdot
\vec{h} = 0
\end{equation}
$$</p>
<p>We can observe that a pair of points gives us two linear equations. Therefore, we could collect a set of point pairs and stack together all the equations to obtain a system of the form:</p>
<p>$$
\begin{equation}
A\cdot\vec{h}=0
\end{equation}
$$</p>
<h3 id="212-noise-amplification-the-horizon-line">2.1.2. Noise amplification: the horizon line<a hidden class="anchor" aria-hidden="true" href="#212-noise-amplification-the-horizon-line">#</a></h3>
<p>Importantly, this system is not very robust to noise corruption, and the contribution to the accuracy of the solution depends on the point location. To understand why, let us focus on the scenario depicted below.</p>
<figure class="figure" style="text-align: center;">
  <img src="/estimating_homography_matrix/PointCorrespondences.png" alt="Point Correspondences" width="90%" style="display: block; margin: auto;">
  <figcaption class="caption" style="font-weight: normal; max-width: 80%; margin: auto;">Example of 4 point pair correspondences.</figcaption>
</figure>
<p>We can observe that the upper sideline is relatively close to the horizon line. In the real world, the distance between its endpoints (red and cyan) is exactly the same as the distance for the bottom sideline endpoints (green and orange).</p>
<p>However, due to the perspective transform, that distance is substantially smaller in the projected space. When we label the pixel coordinates in the left image, a slight error in the points for the top sideline will correspond to a much bigger error in yards than an equivalent pixel error for the bottom sideline.</p>
<p>In order to mitigate the impact of deviations, a common strategy consists of labelling more than the minimum number of required points (four). In this way, we make our system more robust to noise contamination.</p>
<h3 id="213-solution-least-squares-estimator"><strong>2.1.3. Solution: least squares estimator</strong><a hidden class="anchor" aria-hidden="true" href="#213-solution-least-squares-estimator">#</a></h3>
<p>The goal is thus to solve the homogenous system of linear equations of the form</p>
<p>$$
\begin{equation}
A\cdot\vec{h}=0
\end{equation}
$$</p>
<p>Recall that the matrix H has 8 degrees of freedom (DoF). In order to solve this system, we therefore need 8 linearly independent equations. This can be achieved by having 4 different and non-colinear points (or 4 different non-concurrent lines, equivalently).</p>
<p>If we have more points, the system will be overdetermined. In general, that means there will not be an exact solution, so it seems reasonable to instead solve the Total Least Squares (TLS) problem given by</p>
<p>$$
\begin{equation}
h^*=\argmin_h \lVert A\cdot \vec{h} \rVert, \qquad s.t. \,\,\,\,\, \lVert \vec{h} \rVert=1
\end{equation}
$$</p>
<p>We have added an extra constraint in order to avoid the trivial solution $\vec{h}=\vec{0}$. Bear in mind that $H$ is also only determined up to scale, so the unitary norm constraint is not restrictive at all (other constraints are also valid, such as $h_{33} = 1$, which is also a common choice).</p>
<p>This problem can easily be solved by resorting to the Singular Value Decomposition (SVD) of matrix A</p>
<p>$$
\begin{equation}
A=U \cdot\Sigma \cdot V^T
\end{equation}
$$</p>
<p>where $U$ and $V$ are unitary matrices defining an orthonormal basis for the column and row space of $A$ respectively. We can leverage this property for the following equalities</p>
<p>$$
\begin{equation}
\lVert A\cdot\vec{h} \rVert=\lVert U \cdot\Sigma \cdot V^T\cdot\vec{h}\rVert=\lVert \Sigma \cdot V^T\cdot\vec{h}\rVert
\end{equation}
$$</p>
<p>$$
\begin{equation}
\lVert \vec{h} \rVert=\lVert V^T\cdot\vec{h}\rVert
\end{equation}
$$</p>
<p>As a consequence, the system in $(13)$ is equivalent to</p>
<p>$$
\begin{equation}
h^*=\argmin_h \lVert \Sigma \cdot V^T\cdot\vec{h}\rVert, \qquad s.t. \,\,\,\,\, \lVert V^T \cdot \vec{h} \rVert=1
\end{equation}
$$</p>
<p>and if we redefine $V^T\cdot\vec{h}=\vec{g}$, our problem has simplified substantially to</p>
<p>$$
\begin{equation}
\argmin_g \lVert \Sigma \cdot \vec{g}\rVert, \qquad s.t. \,\,\,\,\, \lVert \vec{g} \rVert=1
\end{equation}
$$</p>
<p>Since $\Sigma$ is a diagonal matrix with its elements sorted in decreasing order</p>
<p>$$
\begin{equation}
\lVert \Sigma \cdot \vec{g}\rVert=\sum_i (\sigma_i\cdot g_i)^2
\end{equation}
$$</p>
<p>This sum is minimized by setting</p>
<p>$$
\begin{equation}
\vec{g}=\left[0, 0, \,\,\,\cdots\,\,\,, 0, 1\right]
\end{equation}
$$</p>
<p>Finally, recall that $\vec{h}=V\cdot\vec{g}$, which implies that $\vec{h}$ is just the eigenvector corresponding to the smallest eigenvalue.</p>
<p>On the other hand, if we just have four points or our observations are perfectly noiseless, the system $A\cdot\vec{h}=0$ has a unique solution. In that scenario, $A$ can be reduced to an $8x9$  matrix of rank 8. That means it will have a 1D null-space from which we can compute a non-trivial ($\vec{h}\neq \vec{0})$ solution: the eigenvector corresponding to the null eigenvalue.</p>
<p><strong>Try it yourself!</strong></p>
<p>You can see an example of how to retrieve the camera from a set of point/line correspondences in the <a href="https://github.com/InakiRaba91/ProjectiveGeometry">repository</a>. In order to do so, just install the package (<code>poetry install</code>) and then run</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># from points</span>
</span></span><span style="display:flex;"><span>poetry run python -m projective_geometry homography-from-point-correspondences-demo
</span></span><span style="display:flex;"><span><span style="color:#75715e"># from lines</span>
</span></span><span style="display:flex;"><span>poetry run python -m projective_geometry homography-from-point-correspondences-demo
</span></span></code></pre></div><p>This will generate the following figure when retrieving the homography from a set of point correspondences:</p>
<figure class="figure" style="text-align: center;">
  <img src="/estimating_homography_matrix/CelticsProjectedCourtPoints.png" alt="Homography retrieval from points" width="90%" style="display: block; margin: auto;">
  <figcaption class="caption" style="font-weight: normal; max-width: 80%; margin: auto;">Retrieve homography from annotated points (red). Pitch template projection from retrieved homography is displayed in blue.</figcaption>
</figure>
<p>And the following figure when retrieving the homography from a set of line correspondences:</p>
<figure class="figure" style="text-align: center;">
  <img src="/estimating_homography_matrix/CelticsProjectedCourtLines.png" alt="Homography retrieval from lines" width="90%" style="display: block; margin: auto;">
  <figcaption class="caption" style="font-weight: normal; max-width: 80%; margin: auto;">Retrieve homography from annotated lines (red). Pitch template projection from retrieved homography is displayed in blue.</figcaption>
</figure>
<div style="background-color: lightyellow; border: 1px solid black; padding: 2px 10px; display: flex; align-items: start;">
  <span style="margin-right: 10px;">‚ö†Ô∏è</span>
  <span>
    OpenCV provides a built-in method that retrieves the homography from a set of point correspondences: <a href="https://docs.opencv.org/3.4/d9/d0c/group__calib3d.html#ga4abc2ece9fab9398f2e560d53c8c9780" style="text-decoration: none; color: blue; line-height: 1;"><strong>cv2.findHomography()</strong></a><br><br>
    You can try it out in the repo for comparison by calling:<br><br>
    <pre><code>
      camera = Camera.from_point_correspondences_cv2(
        pts_source=points_template, 
        pts_target=points_frame,
      )
    </code></pre>
    <br><br>
  </span>
</div> <br>
<h2 id="22-from-conics">2.2. From conics<a hidden class="anchor" aria-hidden="true" href="#22-from-conics">#</a></h2>
<figure class="figure" style="text-align: center;">
  <img src="/estimating_homography_matrix/HockeyRinkEllipses.png" alt="Conics in Hockey Ice Rink" width="100%" style="display: block; margin: auto;">
  <figcaption class="caption" style="font-weight: normal; max-width: 80%; margin: auto;">Example of conic correspondences found in an hocker ice rink template.</figcaption>
</figure>
<p>Similarly, we could try and estimate the homography from conic correspondences. We already know conics fulfill the following equation, up to a scale:</p>
<p>$$
\begin{equation}
s\cdot M&rsquo;=H^{-T}\cdot M\cdot H^{-1}
\end{equation}
$$</p>
<p>where the scale factor satisfies</p>
<p>$$
\begin{equation}
s^3\cdot\text{det}(M&rsquo;)=\frac{\text{det}(M)}{\text{det}(H)^2}
\end{equation}
$$</p>
<p>We can freely force $\text{det}(H)=1$, which implies:</p>
<p>$$
\begin{equation}
s=\sqrt[3]{\frac{\text{det}(M)}{\text{det}(M&rsquo;)}}
\end{equation}
$$</p>
<p>Therefore, without loss of generality, we can always normalize $M&rsquo;=s\cdot M$, so $\text{det}(M)=\text{det}(M&rsquo;)$ and get rid of the scaling factor.</p>
<p>Under the assumption that the conics are non-degenerate ($\text{det}(M)\neq 0)$, we can combine this equation for two pair of corresponding ellipses ${(M_i, M_i&rsquo;),\,\, (M_j, M_j&rsquo;)}$</p>
<p>$$
\begin{equation}
M_i^{-1}\cdot M_j=H^{-1}\cdot M_i&rsquo;^{-1}\cdot M_j&rsquo;\cdot H
\end{equation}
$$</p>
<p>or equivalently</p>
<p>$$
\begin{equation}
H\cdot M_i^{-1}\cdot M_j-M_i&rsquo;^{-1}\cdot M_j&rsquo;\cdot H = 0
\end{equation}
$$</p>
<p>This forms a set of linear equations in the items forming the homography matrix $H$. Consequently, we can form a system of equations similar to the one we resolved earlier:</p>
<p>$$
\begin{equation}
B_{ij}\cdot\vec{h}=0
\end{equation}
$$</p>
<p>Importantly, two pairs of ellipses are not enough to uniequivocally determine the homography. We instead need at least 3 pairs of ellipses. By stacking the equations corresponding to each combination of two pairs of ellipses, we arrive at the final system</p>
<p>$$
\begin{equation}
B\cdot\vec{h}=0
\end{equation}
$$</p>
<p>that we can solve following the procedure defined for the previous scenario.</p>
<p><strong>Try it yourself!</strong></p>
<p>You can see an example of how to retrieve the camera from a set of ellipse correspondences in the <a href="https://github.com/InakiRaba91/ProjectiveGeometry">repository</a>. In order to do so, just install the package (<code>poetry install</code>) and then run</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># from ellipses</span>
</span></span><span style="display:flex;"><span>poetry run python -m projective_geometry homography-from-ellipse-correspondences-demo
</span></span></code></pre></div><p>This will generate the following figure:</p>
<figure class="figure" style="text-align: center;">
  <img src="/estimating_homography_matrix/CelticsProjectedCourtEllipses.png" alt="Homography retrieval from conics" width="90%" style="display: block; margin: auto;">
  <figcaption class="caption" style="font-weight: normal; max-width: 80%; margin: auto;">Retrieve homography from annotated ellipses (red). Pitch template projection from retrieved homography is displayed in blue.</figcaption>
</figure>
<h2 id="23-from-multiple-features">2.3. From multiple features<a hidden class="anchor" aria-hidden="true" href="#23-from-multiple-features">#</a></h2>
<figure class="figure" style="text-align: center;">
  <img src="/estimating_homography_matrix/SoccerTemplateMatching.png" alt="Soccer Pitch Template matching" width="100%" style="display: block; margin: auto;">
  <figcaption class="caption" style="font-weight: normal; max-width: 80%; margin: auto;">Example of different types of geometric features correspondences between a football broadcast frame and the pitch template.</figcaption>
</figure>
<p>If we have identified a set of different matching geometric features (i.e.: points, lines, conics), one could solve the problem by trying to minimize a cost function that combines multiple terms. Ideally, one should be able to compute a convex metric that captures the similarity for each type of feature.</p>
<figure class="figure" style="text-align: center;">
  <img src="/estimating_homography_matrix/GeometricFeaturesError.png" alt="Geometric features error" width="80%" style="display: block; margin: auto;">
  <figcaption class="caption" style="font-weight: normal; max-width: 80%; margin: auto;">Example of distances (marked in green) between pairs of (a) points, (b) lines and (c) ellipses.</figcaption>
</figure>
<p>This way, finding the homography boils down to solving the following optimisation problem</p>
<p>$$
\begin{equation}
\vec{h^*} = \argmin \textcolor{blue}{\mathcal{L_{\text{p}}}(\vec{p&rsquo;}, H\cdot\vec{p})} +
\textcolor{red}{\mathcal{L_{\text{l}}}(\vec{l&rsquo;}, H^{-T}\cdot\vec{l})} +
\textcolor{green}{\mathcal{L_{\text{ell}}}(M&rsquo;, H^{-T}\cdot M\cdot H^{-1})}
\end{equation}
$$</p>
<p><strong>Try it yourself!</strong></p>
<p>You can see an example of how to retrieve the camera from a set of point, line and ellipse correspondences in the <a href="https://github.com/InakiRaba91/ProjectiveGeometry">repository</a>. In order to do so, just install the package (<code>poetry install</code>) and then run</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># from ellipses</span>
</span></span><span style="display:flex;"><span>poetry run python -m projective_geometry homography-from-correspondences-demo
</span></span></code></pre></div><p>This will generate the following figure:</p>
<figure class="figure" style="text-align: center;">
  <img src="/estimating_homography_matrix/CelticsProjectedCourtMultiple.png" alt="Homography retrieval from multiple features" width="90%" style="display: block; margin: auto;">
  <figcaption class="caption" style="font-weight: normal; max-width: 80%; margin: auto;">Retrieve homography from annotated points (red), lines (green) and ellipses (yellow). Pitch template projection from retrieved homography is displayed in blue.</figcaption>
</figure>
<h1 id="3-via-a-pair-images">3. Via a pair images<a hidden class="anchor" aria-hidden="true" href="#3-via-a-pair-images">#</a></h1>
<p>So far we have focused in retrieving the homography from a set of matching geometric features. What if instead we are given two photographs of the same scene taken from different angles?</p>
<figure class="figure" style="text-align: center;">
  <img src="/estimating_homography_matrix/EiffelTower.png" alt="Eiffel Tower Perspectives" width="90%" style="display: block; margin: auto;">
  <figcaption class="caption" style="font-weight: normal; max-width: 80%; margin: auto;">Two photographs of the same scene taken from different angles.</figcaption>
</figure>
<p>One way to proceed would be to identify and match geometric features, then apply the previously described procedures. The identification could be done manually, or automatically. The latter has been an active research area over recent decades, and multiple methods can be used, such as Harris corner detector, Canny edge detector, SIFT features, SURF features or ORB features. Interestingly, some of these detectors serve as descriptors too, which in turn provides a way to pair them out of the box.</p>
<p>Alternatively, one could view the homography estimation as a registration problem. Let us say we have two image, the source $I(\vec{x})$ and the target $T(\vec{x})$, where $\vec{x}=[x, y]^T$ corresponds to the pixel coordinates for the images. Moreover, let $W(\vec{x}; \vec{h}) = H\cdot \vec{p}$  be the transform that warps a set of pixels under the projective transform. $H$ would be the homography matrix characterizing the transform, and $\vec{h}$ its vectorized form. Then we can minimize the following cost function:</p>
<p>$$
\begin{equation}
\sum_{\vec{x}} |I(W(\vec{x}; \vec{h})) - T(\vec{x}) |^2
\end{equation}
$$</p>
<p><strong>Lucas-Kanade (LK)</strong> is a popular iterative algorithm widely used to tackle this kind of problem [6]. It relies on the computation of the gradient, under the assumption that objects may be located at different positions across the two images, but their appearance remains the same. There are multiple extensions, such as:</p>
<ul>
<li>Hierarchical LK: resolves the problem at multiple resolutions to estimate iteratively gross-to-fine motion.</li>
<li>Multimodal LK: for images where contrast varies (such as in between CT-scans and MRIs), but structure remains. Thus, the pixel intensity similarity is not a valid metric anymore. Instead, metrics based on entropy or sparisty can be used (see [7] for details).</li>
</ul>
<p>Given a set of geometric features identified in one of the images, LK algorithm can also be used directly to solve the matching step. However, it is important to rely on static features. If moving objects are used instead, that would corrupt the estimation of the camera motion.</p>
<p><strong>Try it yourself!</strong></p>
<p>You can see an example of how to retrieve the camera from two images in the <a href="https://github.com/InakiRaba91/ProjectiveGeometry">repository</a>. In order to do so, just install the package (<code>poetry install</code>) and then run</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># from ellipses</span>
</span></span><span style="display:flex;"><span>poetry run python -m projective_geometry homography-from-image-registration
</span></span></code></pre></div><p>This will grab the following two images:</p>
<div style="display: flex; justify-content: space-around;">
  <figure class="figure" style="text-align: center; width: 45%;">
    <img src="/estimating_homography_matrix/Target.png" alt="Target image" style="display: block; margin: auto;">
    <figcaption class="caption" style="font-weight: normal; max-width: 80%; margin: auto;">Target image we‚Äôre trying to align against.</figcaption>
  </figure>
  <figure class="figure" style="text-align: center; width: 45%;">
    <img src="/estimating_homography_matrix/Source.png" alt="Source image" style="display: block; margin: auto;">
    <figcaption class="caption" style="font-weight: normal; max-width: 80%; margin: auto;">Source image we‚Äôre trying to align.</figcaption>
  </figure>
</div>
<p>It will try to find a set of matching keypoints in both, as illustrated below:</p>
<figure class="figure" style="text-align: center;">
  <img src="/estimating_homography_matrix/Matches.png" alt="Image matches" width="90%" style="display: block; margin: auto;">
  <figcaption class="caption" style="font-weight: normal; max-width: 80%; margin: auto;">Set of identified matching keypoints.</figcaption>
</figure>
<p>And it will use those to retrieve the homography that allows to warp the source image (red border) onto the target one:</p>
<figure class="figure" style="text-align: center;">
  <img src="/estimating_homography_matrix/Warped.png" alt="Warped image" width="90%" style="display: block; margin: auto;">
  <figcaption class="caption" style="font-weight: normal; max-width: 80%; margin: auto;">Source image (red border) warped onto the target image with the retrieved homography..</figcaption>
</figure>
<h1 id="4-via-ml-model">4. Via ML model<a hidden class="anchor" aria-hidden="true" href="#4-via-ml-model">#</a></h1>
<p>Finally, a modern approach to tackle the homography estimation problem consists of using an ML trained model that is able to predict the projective transform given the input. If we‚Äôre trying to align two given images, those would serve as the input to the model. Alternatively, if we‚Äôre trying to map a given image to pre-defined template, one would only need to provide the former, since the template is static. For the sake of simplicity, we will focus on this second case.</p>
<figure class="figure" style="text-align: center;">
  <img src="/estimating_homography_matrix/NonColinearMatches.png" alt="Non Colinear Matches" width="100%" style="display: block; margin: auto;">
  <figcaption class="caption" style="font-weight: normal; max-width: 80%; margin: auto;">a) Model that predicts the projective transform parametrisation that aligns two given images, b) Model that predicts the projective transform parametrisation that aligns a given image against a pre-defined static template.</figcaption>
</figure>
<p>One feature that seems to have a substantial impact in the quality of the predictions is the parametrisation used to characterize the projective transform. The possible  choices are:</p>
<ol>
<li>
<p><strong>Homography matrix</strong>: the model would directly regress the parameters in the homography matrix. However, as pointed out in [8], those parameters consist of a mix of both rotational, translational and shearing terms. Therefore, they will likely vary in very different scales, so it would be necessary to balance their contribution to the loss.</p>
</li>
<li>
<p><strong>Projected geometric features</strong>: alternatively one could parametrize the homography by the projected coordinates of a set of pre-defined geometric features. In the simplest case, it would suffice to use 4 points, as proposed in [8, 9]. Alternatively, in order to increase the robustness in the prediction, one could create a grid of $N\times M$points and predict the locations for all of them. Moreover, one could also predict other features such as lines, ellipses‚Ä¶ as done in [11].
<br><br>
From the two set of geometric features (the pre-defined static one, and its projected version predicted by the model), it would suffice to apply one of the procedures described before in order to retrieve the homography matrix.
<br><br>
For the sake of the explanation, let us say we choose to predict the location of the projection for a set of points within a rectangular grid. Another important choice is therefore what domain to predict their location in. There are two choices here:
<br><br></p>
<ol>
<li><u>Template domain</u>: this forces the model to implicitly learn the mechanics of the projective transform, since it will have to learn their location after projecting the image grid to the template domain (see below).</li>
</ol>
 <figure class="figure" style="text-align: center;">
   <img src="/estimating_homography_matrix/TemplateProjectedGrid.png" alt="Template Projected Grid" width="90%" style="display: block; margin: auto;">
   <figcaption class="caption" style="font-weight: normal; max-width: 80%; margin: auto;">a) Static grid in image domain whose projection the model will have to learn, b) Projected grid predicted by the model for the given frame.</figcaption>
 </figure>
 <p style="padding-left: 20px;">
   The hope is that the model, by means of ingesting enough data, is able to learn these mechanics. However, it seems very inefficient to ask the model to learn this transform when its characterization is already known and mathematically described. Therefore, the following approach seems a much better way to tackle the problem.
 </p>
<ol start="2">
<li><u>Image domain</u>: this alleviates the complexity of the task at hand, since the model will only have to learn to identify the relevant keypoints in the given image.</li>
</ol>
 <figure class="figure" style="text-align: center;">
   <img src="/estimating_homography_matrix/ImageProjectedGrid.png" alt="Image Projected Grid" width="90%" style="display: block; margin: auto;">
   <figcaption class="caption" style="font-weight: normal; max-width: 80%; margin: auto;">a) Static grid in template domain whose back-projection the model will have to learn, b) Back-projected grid predicted by the model for the given frame.</figcaption>
 </figure>
 <p style="padding-left: 20px;">
   As we have stated, by using a grid with more than the bare minimum required (4 points), we make the process more robust to noise corruption. However, this comes at a cost: the model is now free to predict the keypoints in a way that does not correspond to a projective deformation of a rectangular grid.
   <br><br>
   Once again, the expectation is that, with enough data, the model will implicitly learn there is a relationship between the keypoints in the grid. But asking the model to learn that well-known relationship seems an inefficient usage of the available data. So there is a trade-off there between robustness and data efficiency.
 </p>
</li>
</ol>
<p>On the other hand, predicting the features location allows for another in choice. The problem can be posed as:</p>
<ul>
<li><strong>Regression problem</strong>: in this case, one would simply train the model to predict the x-y coordinates of the geometric feature in question, resorting to any regression loss such as the l2 distance.</li>
</ul>
<figure class="figure" style="text-align: center;">
  <img src="/estimating_homography_matrix/RegressionModel.png" alt="Regression Model" width="90%" style="display: block; margin: auto;">
  <figcaption class="caption" style="font-weight: normal; max-width: 80%; margin: auto;">Model is asked to find pixel (x-y) coordinates of selected template keypoint (marked in cyan) in the given image.</figcaption>
</figure>
<ul>
<li><strong>Classification problem</strong>: alternatively, one could train the model to predict the probability of each pixel in the image corresponding to the seek-out keypoint, and then estimate its location by taking the one with the highest one.</li>
</ul>
<figure class="figure" style="text-align: center;">
  <img src="/estimating_homography_matrix/ClassificationModel.png" alt="Classification Model" width="90%" style="display: block; margin: auto;">
  <figcaption class="caption" style="font-weight: normal; max-width: 80%; margin: auto;">Model is asked to predict the probability (color-coded in grayscale) of a pixel in the given image to correspond to selected template keypoint (marked in cyan).</figcaption>
</figure>
<p>Why bother to solve a regression problem via classification instead? Well, although this is not yet well-understood, there is empirical evidence pointing towards classification being more accurate at the regression task. The following Twitter thread provides some insights of why that might be the case.</p>
<div style="display: flex; justify-content: center;">
  <blockquote class="twitter-tweet"><p lang="en" dir="ltr">...</p>&mdash; Name (@username) <a href="https://twitter.com/ducha_aiki/status/1587366668845588480">Date</a></blockquote>
</div>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
One hypothesis revolves around the gradient computation during training. [12] argues that regression loss results in a smaller gradient the closer we get to the correct output. On the other hand, the gradient for the classification loss does not depend on how close we are to the underlying true value. This means that for bad predictions, the first loss is able to correct faster. However, once the prediction enters the small error regime, the classification approach would be more effective at narrowing the gap to the ground-truth.
<p>Another hypothesis suggests that when dealing with multi-modal data, whereas regression forces the model to make a choice, classification allows it to express uncertainty. In our case, the model could express that by assigning similar probability scores to multiple disjoint areas in the image. In such a way, the model may therefore be able to better capture the underlying multi-modal distribution of the input.</p>
<h1 id="5-summary">5. Summary<a hidden class="anchor" aria-hidden="true" href="#5-summary">#</a></h1>
<p>In this post we have shown multiple approaches that allow to retrieve the homography matrix. Those include:</p>
<ul>
<li>Techniques that rely on <strong>manual input</strong>, i.e. labelled geometric features such as keypoints, lines or ellipses.</li>
<li>Techniques exploiting <strong>classical computer vision algorithms</strong>, such as Lukas-Kanade.</li>
<li>Techniques based on Deep Learning models</li>
</ul>
<p>The latter constitute the state-of-the-art and is illustrated in the video below. It displays the pitch template (red) projected using the homography retrieved in a fully automated fashion.</p>
<figure class="figure" style="text-align: center;">
  <video src="/estimating_homography_matrix/HomographyDemo.mp4" width="90%" controls style="display: block; margin: auto;">
    Homography demo
  </video>
  <figcaption class="caption" style="font-weight: normal; max-width: 80%; margin: auto;">Example of homography estimation in video clip.</figcaption>
</figure>
<h1 id="6-references">6. References<a hidden class="anchor" aria-hidden="true" href="#6-references">#</a></h1>
<ol>
<li>Richard Hartley and Andrew Zisserman (2000), <em>Multiple View Geometry in Computer Vision</em>, Cambridge University Press.</li>
<li>Henri P. Gavin (2017), CEE 629 Lecture Notes. System Identification Duke University, <em>Total Least Squares</em></li>
<li>Richard Szeliski (2010), <em>Computer Vision: Algorithms and Applications</em>, Springer</li>
<li><a href="https://docs.opencv.org/3.4/d9/dab/tutorial_homography.html">OpenCV Libary: Basic concepts of the homography explained with code</a></li>
<li>Juho Kannala et. al. (2006), <em>Algorithms for Computing a Planar Homography from Conics in Correspondence,</em> Proceedings of the British Machine Vision Conference 2006.</li>
<li>Simon Baker and Iain Matthews (2004), <em>Lucas-Kanade 20 years on: A unifying framework</em>. International Journal of Computer Vision.</li>
<li>Lucilio Cordero Grande et. al. (2013), <em>Groupwise Elastic Registration by a New Sparsity-Promoting Metric: Application to the Alignment of Cardiac Magnetic Resonance Perfusion Images,</em> IEEE Transactions on Pattern Analysis and Machine Intelligence.</li>
<li>Detone et.al. (2016), <em><a href="https://arxiv.org/abs/1606.03798">Deep Image Homography Estimation</a></em>, arXiv.</li>
<li>Ty Nguyen et. al. (2018), <em><a href="https://arxiv.org/abs/1709.03966">Unsupervised Deep Homography: A Fast and Robust Homography Estimation Model</a>,</em> arXiv.</li>
<li>Wei Jiang et. al. (2019), <em>Optimizing Through Learned Errors for Accurate Sports Field Registration</em>, 2020 IEEE Winter Conference on Applications of Computer Vision (WACV)</li>
<li>Xiaohan Nie et. al. (2021), <em>A Robust and Efficient Framework for Sports-Field Registration,</em> 2021 IEEE Winter Conference on Applications of Computer Vision (WACV)</li>
<li>James McCaffrey (2013), <em><a href="https://jamesmccaffrey.wordpress.com/2013/11/05/why-you-should-use-cross-entropy-error-instead-of-classification-error-or-mean-squared-error-for-neural-network-classifier-training/">Why You Should Use Cross-Entropy Error Instead Of Classification Error Or Mean Squared Error For Neural Network Classifier Training</a></em></li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/computer-vision/">Computer Vision</a></li>
      <li><a href="http://localhost:1313/tags/projective-geometry/">Projective Geometry</a></li>
      <li><a href="http://localhost:1313/tags/homography-matrix/">Homography Matrix</a></li>
      <li><a href="http://localhost:1313/tags/pinhole-camera/">Pinhole Camera</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://localhost:1313/">I√±aki‚Äôs Log</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script src="/js/figure-numbering.js"></script>
</body>

</html>
